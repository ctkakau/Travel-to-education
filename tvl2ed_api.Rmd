---
title: "TravToEd_queries"
author: 'Chad Kakau: 300212228'
date: "2024-12-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, include = F, message = F)
authKey <- "5dc60d5341c3446690edc70c8bdf67ab"
```


Use this document to retrieve census data from the Aotearoa Data Explorer site and import for analysis without downloading a file.  The Aotearoa Data Explorer API page provides for a range of query types, for retrieving data we will use:  

  - GET data queries, or
  - GET data by the key
  
There are other queries that could be used for creating an interface that allows users to select their own filters and outputs:  

  - GET Data availability
  - GET information about data availability
  
# General process:  

1. identify key datasets
2. generate api query
3. retrieve and reshape data
4. conduct analysis
5. generate a couple of outputs.

## 1. identify key datasets  

Key datasets will be the travel to education responses from the 2018 and 2023 census years.  Try to import at a range of levels, summarised at SA1, SA2, SA3, Territorial Authority, Regional Council, and Urban/Rural.

### determine data availability  

We can first use the GET Data availability function to determine relevant data keys.  

The data set is available from Statistics New Zealand (agency ID: STATSNZ) and the "travel to education" data is part of the resource ID: CEN23_TRA_001 (the 'transport' concept within the census 2023 data).  To give helpful context to the "travel to education" additional dimensions, or "components" are defined and each component includes individual levels (e.g. "walk or jog", "bicycle", etc.) and aggregations (e.g. "total", "median"):    

  - CEN23_YEAR_001: census year
  - CEN23_TED_002: main means of travel
  - CEN23_AGE_003: age category (available at 5-year groupings)
  - CEN23_GEN_002: gender category
  - CEN23_EDU_001: location by educational institution address  

For this initial example, we will make a "GET data availability by key" request to the Aotearoa Data Explorer API.  The request takes the form:

  - GET https://apis.stats.govt.nz/ade-api/rest/v2/availability/{context}/{agencyId}/{resourceId}/{version}/{key}/{componentId}  

with the following parameter values:  

  - context: "dataflow"
  - agencyId: "STATSNZ"
  - resourceId: "CEN23_TRA_001"
  - version: "1.0"
  - key: "2023"
  - componentId: "CEN23_YEAR_001,CEN23_TED_002,CEN23_AGE_003,CEN23_GEN_002"  

The Aotearoa Date Explorer API requires other information, including authentication and output format, so these are included when constructing the request.

```{r getDataAvailability_request, echo=T, include=T}
# check availability for data from the Census 2023 Transport concept.  The GET Data availability query has the format:
# GET https://apis.stats.govt.nz/ade-api/rest/v2/availability/{context}/{agencyId}/{resourceId}/{version}/{key}/{componentId}
library(httr2) # interact with api
library(xml2) # handle xml nodes and data
library(XML) # parse xml
library(purrr) # pluck function
library(dplyr) # glimpse function

context <- 'dataflow'
agencyId <- 'STATSNZ'
resourceId <- 'CEN23_TRA_001'
version <- '1.0'
key <- '2023'
componentId <- 'CEN23_YEAR_001,CEN23_TED_002,CEN23_AGE_003,CEN23_GEN_002'
# ,CEN23_EDU_001 # this categorises at SA2 level... too many lines :(
base_path <- request("https://apis.stats.govt.nz/ade-api/rest") %>%
  req_headers(
    `Ocp-Apim-Subscription-Key`= authKey,
    .redact = "Ocp-Apim-Subscription-Key",
    `Cache-Control` = 'no-cache',
    `accept-encoding` = 'identity'
  ) 

data_avail_req <- base_path %>%
  req_url_path_append("v2") %>%
  req_url_path_append("availability") %>%
  req_url_path_append(context) %>%
  req_url_path_append(agencyId) %>%
  req_url_path_append(resourceId) %>%
  req_url_path_append(version) %>%
  req_url_path_append(key) %>%
  req_url_path_append(componentId) %>%
  req_url_query(
    mode = 'available',
    format = 'xml'
  )

# this is what the request will look like
req_dry_run(data_avail_req)
```

The "GET data availability by key" request has been constructed and can be sent to the Aotearoa Data Explorer API.

```{r getDataAvailability_response, echo=T, include = T}
data_avail_resp <- req_perform(data_avail_req) 

available_data <- data_avail_resp %>%
  resp_body_xml() %>%
  # xml_attrs()
  xmlTreeParse(asText=T) %>%
# follow Albert Rapp's approach using purrr::pluck to dig into nested list
# plucked <- available_data |>
  pluck("doc", 1, "Structures", "Constraints", "ContentConstraint", "CubeRegion")

# available keys within each category
xmlSApply(pluck(available_data), xmlValue)
# available years for CEN23_YEAR_001
xmlSApply(pluck(available_data,1), xmlValue)
# available modes and summaries for CEN23_TED_002
xmlSApply(pluck(available_data,2), xmlValue)
# available  age groupings for CEN23_AGE_003
xmlSApply(pluck(available_data,3), xmlValue)
# available gender groupings for CEN23_GEN_002
xmlSApply(pluck(available_data,4), xmlValue)

close(data_avail_resp)
```

### __GET info about data availability__ query  

Retrieve decodes for different levels of each dimension using the form:  

  - GET "https://apis.stats.govt.nz/ade-api/rest/availableconstraint/{flowRef}/{key}"  

And then use these decodes to add meaningful names to each level.

```{r getDataInfo_req}
# GET "https://apis.stats.govt.nz/ade-api/rest/availableconstraint/{flowRef}/{key}"
# change flowRef
flowRef <- "CEN23_TRA_001"
key <- "all"

data_info_req <- base_path |>
  req_url_path_append("availableconstraint") |>
  req_url_path_append(flowRef) |>
  req_url_path_append(key) |>
  req_url_query(
    mode = "exact",
    references = "codelist")
  
req_dry_run(data_info_req)
```

```{r getDataInfo_resp}

data_info_resp <- req_perform(data_info_req) 

```

```{r getDataInfo}
data_info_base <- data_info_resp |>
  resp_body_xml() |>
  as_list()
  
close(data_info_resp)  

TED_dims <- data_info_base |>
  pluck(1, "Structures", "Codelists") |>
  map_dfr(
    \(x) {
      tibble(
        dimension = x |>  pluck(1, 1, 1)
      )    
      }
  ) 
TED_dims

# str(data_info_base$Structure, max.level= 3)

tibb <- pluck(data_info_base,
      # 1, "Structures", "Codelists", "Codelist", 4, "Name", 1
      "Structure", "Structures", "Codelists"
      #, "Codelist", "Code", "Name", 1
      # "Code", "Name", 1 accesses individual code value (e.g. "15-29 years")
      # "Name" gives dimension name (e.g. "Age")
      ) |>
  map_dfr(
    \(x) {
      tibble(
        value = x |> 
          pluck(1, "Code",
            #"Codelist", "Code", "Name", 1
            ) 
          )
    }
  ) #|>
  #pluck("Code", "Name") |>

```




### __GET data structures__ query  

The "GET data structures" query allows a user to retrieve the structure of data within Aotearoa Data Explorer API, and takes the form:  

  - "GET http://apis.stats.govt.nz/ade-api/rest/{structure}/{agencyId}/{resourceId}[?references][&detail]"  

For the "travel to education" data, the relevant parameters are:  

  - structure: "dataflow"
  - agencyId: "STATSNZ"
  - resourceId: "CEN23_TRA_001" 

The query can be constructed for sending.  

```{r getDataStructures_req, echo=T, include=T}
# format:  "GET http://apis.stats.govt.nz/ade-api/rest/{structure}/{agencyId}/{resourceId}[?references][&detail]"
library(httr2)
library(xml2)
library(dplyr)
library(purrr)

# query components
structure <- "dataflow"
agencyId <- "STATSNZ"
resourceId <- "CEN23_TRA_001"
# construct data queries
data_structure_req <- base_path |>
  req_url_path_append(structure) |>
  req_url_path_append(agencyId) |>
  req_url_path_append(resourceId) |>
  req_url_query(
    references = "none",
    detail = "allcompletestubs"
  ) |>
  req_headers(
    format = "xml"
  )

req_dry_run(data_structure_req)
```

```{r getDataStructures_resp, echo=T, include=T}
data_structure_resp <- req_perform(data_structure_req) 

data_structure <- data_structure_resp|>
  resp_body_xml() |>
  as_list()|>
  pluck("Structure", "Structures", "Dataflows", "Dataflow", "Annotations") |>
  map_dfr(
    \(x) {
      tibble(
        layout = x |> pluck(2, 1),
        defn = x |> pluck(1, 1),
      )
    }
) 

# structure information
data_structure

# close connection
close(data_structure_resp)
```


Create a query to identify whether data is available in the database.  To request data availability, users must provide the following elements:  

  - context:
  - agencyId:
  - resourceId:
  - version:
  - key:
  - componentId:
  
Users can also provide optional information for:  

  - mode:
  - references:

the 'GET data query' retrieves the same response as the test function on Aotearoa Data Explorer API test page, but it doesn't show the data


# __'GET data by key'__ query

```{r q_getDataByKey, echo=T, include=T}
# get data by the key
# 'http://apis.stats/govt.nz/ade-api/rest/data'/{flowRef}/{key}[?dimenstionAtObservation][&detail][&includeHistory]
flowRef <- 'STATSNZ,CEN23_TRA_001,1.0'
key <- "2018+2023.9999.010+009+008+007+006+005+004+003+002+001.99.99"

data_by_key_req <- base_path |>
  req_url_path_append('data') |> 
  req_url_path_append(flowRef) |>
  req_url_path_append(key) |>
  req_url_query(
    format = 'csv',
    detail = "full"
  )

req_dry_run(data_by_key_req)

data_by_key_resp <- req_perform(data_by_key_req)

# close connection
close(data_by_key_resp)

# convert the response to something readable
data_by_key <- data_by_key_resp |>
  resp_body_string() |>
  readr::read_csv() |>
  select(
    contains("YEAR"),
    contains("TED"),
    contains("VALUE")
  ) 

data_by_key

# create a contingency table
data_by_key_tbl <- stats::xtabs(OBS_VALUE~CEN23_TED_002 + CEN23_YEAR_001, data = data_by_key)

str(data_by_key_tbl)

data_by_key_tbl


fit.dbk <- glm(OBS_VALUE~CEN23_TED_002+CEN23_YEAR_001,
            data = data_by_key,
            family = "poisson")

summary(fit.dbk)

pchisq(fit.dbk$deviance, fit.dbk$df.residual)
```

Well, what does this tell us?  

1. we can retrieve data from API-ADE and it comes back in xml format
2. for the query we ran, we can break the results out, but it takes a bit of work
3. we have a better understanding of the structure of the data:  
  - we can start decoding the key `r URLdecode(key)` 
  - '2018+2023' are the key values for year (Value id="CEN23_YEAR_001")
  - '9999' is key value for something CEN23_EDU_001 (is this total by educational institute address)
  - '7777' is key value for total education institute address by regional council
  - '999' is key value for 'total travel to education' (Value id = 'CEN23_TED_002')
  - three digit indicators are key values for each means of travel to education
  - '99' are key values for 'total gender' and 'total age groups'
  
## what about just downloading csv and making contingency table

```{r csvYear}
# # # read in the csv table
# # ted_year <- read.csv("/home/chad/Downloads/STATSNZ,CEN23_TRA_001,1.0+2018+2023.9999.010+009+008+007+006+005+004+003+002+001.99.99 (1).csv") |>
# #   select(OBS_VALUE,
# #          !c(contains("_"),
# #             ends_with(c(".Value", ".Status")),
# #            STRUCTURE,
# #            ACTION,
# #            )
# #          ) #|>
#   
# year_glm_f <- glm(OBS_VALUE~factor(Census.year), 
#     data=  ted_year,
#     family = 'poisson')
# 1-(pchisq(year_glm_f$deviance, year_glm_f$df.residual))
# 
# year_glm <- glm(OBS_VALUE~Census.year, 
#     data=  ted_year,
#     family = 'poisson')
# 
# summary(year_glm_f)
# summary(year_glm)
```


