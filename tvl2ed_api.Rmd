---
title: "TravToEd_queries"
author: 'Chad Kakau: 300212228'
date: "2024-12-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, include = F, message = F)
authKey <- "5dc60d5341c3446690edc70c8bdf67ab"
shapeKey <- "92c010068afb47089f76501613231717" #TED23
# territorial authority shapefile data
# https://datafinder.stats.govt.nz/services/query/v1/vector.json?key=92c010068afb47089f76501613231717&layer=111194&x=[x]&y=[y]&max_results=3&radius=10000&geometry=true&with_field_names=true
```


Use this document to retrieve census data from the Aotearoa Data Explorer site and import for analysis without downloading a file.  The Aotearoa Data Explorer API page provides for a range of query types, for retrieving data we will use:  

  - GET data queries, or
  - GET data by the key
  
There are other queries that could be used for creating an interface that allows users to select their own filters and outputs:  

  - GET Data availability
  - GET information about data availability
  
# General process:  

1. identify key datasets
2. generate api query
3. retrieve and reshape data
4. conduct analysis
5. generate a couple of outputs.

## 1. identify key datasets  

Key datasets will be the travel to education responses from the 2018 and 2023 census years.  Try to import at a range of levels, summarised at SA1, SA2, SA3, Territorial Authority, Regional Council, and Urban/Rural.

### GET information about data availability  

We can first use the "httr2" package to access the Aotearoa Data Explorer API and call the "GET information about Data availability" query to determine relevant data keys.  The data set is available from Statistics New Zealand (agency ID: STATSNZ) and the "travel to education" data is part of the resource ID: CEN23_TRA_001 (the 'transport' concept within the census 2023 data).  To give helpful context to the "travel to education" data, additional dimensions, or "components" are defined and each component includes individual levels (e.g. "walk or jog", "bicycle", etc.) and aggregations (e.g. "total", "median").  The key dimensions relating to the "travel to education" concept are:    

  - CEN23_YEAR_001: census year
  - CEN23_TED_002: main means of travel
  - CEN23_AGE_003: age category (available at 5-year groupings)
  - CEN23_GEN_002: gender category
  - CEN23_EDU_001: location by educational institution address  

For this initial example, we will make a "GET information about data availability" request to the Aotearoa Data Explorer API.  The request takes the form:

  - GET "https://apis.stats.govt.nz/ade-api/rest/availableconstraint/{flowRef}/{key}"  

with the following parameter values:  

  - flowRef: "STATSNZ,CEN23_TRA_001,1.0
  - key: "2023

Parameters for other queries could include:  

  - context: "dataflow"
  - agencyId: "STATSNZ"
  - resourceId: "CEN23_TRA_001"
  - version: "1.0"
  - key: "2023"
  - componentId: "CEN23_YEAR_001,CEN23_TED_002,CEN23_AGE_003,CEN23_GEN_002"  

The Aotearoa Date Explorer API requires other information, including authentication and output format, so these are included when constructing the request.

```{r getDataBaseElements}
# check availability for data from the Census 2023 Transport concept.  The GET Data availability query has the format:
# GET https://apis.stats.govt.nz/ade-api/rest/v2/availability/{context}/{agencyId}/{resourceId}/{version}/{key}/{componentId}
library(httr2) # interact with api
library(xml2) # handle xml nodes and data
library(XML) # parse xml
library(purrr) # pluck function
library(dplyr) # glimpse function

context <- 'dataflow'
agencyId <- 'STATSNZ'
resourceId <- 'CEN23_TRA_001'
version <- '1.0'
key <- '2023'
componentId <- 'CEN23_YEAR_001,CEN23_TED_002,CEN23_AGE_003,CEN23_GEN_002'
# ,CEN23_EDU_001 # this categorises at SA2 level... too many lines :(
base_path <- request("https://apis.stats.govt.nz/ade-api/rest") %>%
  req_headers(
    `Ocp-Apim-Subscription-Key`= authKey,
    .redact = "Ocp-Apim-Subscription-Key",
    `Cache-Control` = 'no-cache',
    `accept-encoding` = 'identity'
  ) 
```

```{r getDataInfo_req}
# GET "https://apis.stats.govt.nz/ade-api/rest/availableconstraint/{flowRef}/{key}"
# change flowRef
flowRef <- "CEN23_TRA_001"
key <- "all"

data_info_req <- base_path |>
  req_url_path_append("availableconstraint") |>
  req_url_path_append(flowRef) |>
  req_url_path_append(key) |>
  req_url_query(
    mode = "exact",
    references = "codelist")
```

Using the "httr2" package in R we can construct and preview the request to check the structure and then send the request to the server. 

```{r getDataInfo_resp, include=T}
# preview the request
req_dry_run(data_info_req)

# perform request
data_info_resp <- req_perform(data_info_req) 
```

We need to extract the relevant information from the response and can draw on the "xml2" package to handle the response.  Since we are interested in identifying the relevant levels within each dimension we extract the name of each dimension (e.g. year, Age etc.) and the name and numeric code for each level within the dimension.  We can use the codes to build more focussed queries and to organise data in the responses.  


```{r getDataInfo}
# convert the response to nested list
data_info_base <- data_info_resp |>
  resp_body_xml() |>
  as_list()
```

Using the "purrr" package within R, we can extract the relevant information and construct objects for holding the information.

```{r getDataInfoDimTables}
# retrieve Travel to Education dimension names
TED_dims <- data_info_base |>
  pluck(1, "Structures", "Codelists") |>
  map_dfr(
    \(x) {
      tibble(
        CL =  x |> attr("id") |> strsplit(split = "CL_") |> pluck(1, 2),  
        dimension = x |>  pluck("Name", 1)
      )    
      }
  ) 

str(data_info_base$Structure$Structures$Codelists$Codelist, max.level=4)[[1]]
data_info_base$Structure$Structures$Codelists$Codelist |>
  list(
  pluck("Code") #$Code$Annotations$Annotation$AnnotationText
  )
# extract code and decodes for levels in Travel to Education dimensions
TED_tables <- map(data_info_base$Structure$Structures$Codelists,
                 \(x) {
                   map_dfr(x,
                           \(y) {
                             list(
                               description = y |> pluck("Name", 1),
                               long_code = y |>  attr("id")
                             )
                           }
                   )
                 }
)
                            
# rename tables to dimensions
names(TED_tables) <- TED_dims$dimension

# close the response and remove the object
close(data_info_resp)
# tidy environment by removing unnecessary objects
rm(list = c("data_info_req", "data_info_resp", "data_info_base"))
```

We can preview the decoded Travel to Education levels within each dimension:  

```{r tidyDataInfo, include=TRUE}
# output the header of dimensions
head(TED_tables)
```




# __'GET data by key'__ query

```{r q_getDataByKey, echo=T, include=T}
# get data by the key
# 'http://apis.stats/govt.nz/ade-api/rest/data'/{flowRef}/{key}[?dimenstionAtObservation][&detail][&includeHistory]
flowRef <- 'STATSNZ,CEN23_TRA_001,1.0'
key <- "2018+2023.9999.010+009+008+007+006+005+004+003+002+001.99.99"

data_by_key_req <- base_path |>
  req_url_path_append('data') |> 
  req_url_path_append(flowRef) |>
  req_url_path_append(key) |>
  req_url_query(
    format = 'csv',
    detail = "full"
  )

req_dry_run(data_by_key_req)

data_by_key_resp <- req_perform(data_by_key_req)



# convert the response to something readable
data_by_key <- data_by_key_resp |>
  resp_body_string() |>
  readr::read_csv() |>
  select(
    contains("YEAR"),
    contains("TED"),
    contains("VALUE")
  ) 

data_by_key

# create a contingency table
data_by_key_tbl <- stats::xtabs(OBS_VALUE~CEN23_TED_002 + CEN23_YEAR_001, data = data_by_key)

str(data_by_key_tbl)

data_by_key_tbl
```


```{r fitTEDYear, echo=T, include=T}
# close connection
close(data_by_key_resp)

fit.dbk <- glm(OBS_VALUE~CEN23_TED_002+CEN23_YEAR_001,
            data = data_by_key,
            family = "poisson")

summary(fit.dbk)

pchisq(fit.dbk$deviance, fit.dbk$df.residual)
```

Well, what does this tell us?  

1. we can retrieve data from API-ADE and it comes back in xml format
2. for the query we ran, we can break the results out, but it takes a bit of work
3. we have a better understanding of the structure of the data:  
  - we can start decoding the key `r URLdecode(key)` 
  - '2018+2023' are the key values for year (Value id="CEN23_YEAR_001")
  - '9999' is key value for something CEN23_EDU_001 (is this total by educational institute address)
  - '7777' is key value for total education institute address by regional council
  - '999' is key value for 'total travel to education' (Value id = 'CEN23_TED_002')
  - three digit indicators are key values for each means of travel to education
  - '99' are key values for 'total gender' and 'total age groups'
  



## what about just downloading csv and making contingency table

```{r csvYear}
# # # read in the csv table
# # ted_year <- read.csv("/home/chad/Downloads/STATSNZ,CEN23_TRA_001,1.0+2018+2023.9999.010+009+008+007+006+005+004+003+002+001.99.99 (1).csv") |>
# #   select(OBS_VALUE,
# #          !c(contains("_"),
# #             ends_with(c(".Value", ".Status")),
# #            STRUCTURE,
# #            ACTION,
# #            )
# #          ) #|>
#   
# year_glm_f <- glm(OBS_VALUE~factor(Census.year), 
#     data=  ted_year,
#     family = 'poisson')
# 1-(pchisq(year_glm_f$deviance, year_glm_f$df.residual))
# 
# year_glm <- glm(OBS_VALUE~Census.year, 
#     data=  ted_year,
#     family = 'poisson')
# 
# summary(year_glm_f)
# summary(year_glm)
```


